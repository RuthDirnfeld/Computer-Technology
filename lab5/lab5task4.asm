;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; 1DT301, Computer Technology I
; Date: 2017-10-09
; Author:
; Student name 1 Ruth Dirnfeld
; Student name 2 Alexandra Bjäremo
;
; Lab number: 5
; Title: Display JHD202
;
; Hardware: STK600, CPU ATmega2560
;
; Function: Display each line during five seconds
;
; Input ports: TX, RX on PIND2, PIND3.
;
; Output ports: LCD display connected to DDRE.
;
; Subroutines: If applicable.
; Included files: m2560def.inc
;
; Other information: Clock set at 1MHz.
;
; Changes in program: 2017-11-06, 2017-11-08, 2017-11-15
;
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


.include "m2560def.inc"

.equ BITMODE4 = 0b00000010     ; 4-bit operation
.equ CLEAR = 0b00000001        ; Clear display
.equ DISPCTRL = 0b00001111     ; Display on, cursor on, blink on.  //DISP_CTRL
.equ MEMORY = 0x600

.def Temp = r16
.def Data = r17
.def RS = r18
.def Temp2 = r28
.def counter = r29
.def char = r25

.cseg
.org 0x0000 ; Reset vector
jmp reset
.org URXC1addr
rjmp read_char

.org 0x0072

reset :
; Init stack pointer
ldi temp, HIGH(RAMEND)
out SPH, temp
ldi temp, LOW(RAMEND)
out SPL, temp

ldi temp2, 23
sts UBRR1L, temp2
ldi temp2, (1<<TXEN1) | (1<<RXEN1 | 1<<RXCIE1)
sts UCSR1B, temp2
sei

ser temp
out ddre, temp
clr temp
out porte, temp

init_disp:
rcall power_up_wait       ; wait for display to power up
ldi Data, BITMODE4        ; 4-bit operation
rcall write_nibble        ; (in 8-bit mode)
rcall short_wait          ; wait min. 39 us
ldi Data, DISPCTRL        ; disp. on, blink on, curs. On
rcall write_cmd           ; send command
rcall short_wait          ; wait min. 39 us

ldi XH, HIGH(MEMORY)
ldi XL, LOW(MEMORY)

ldi counter, 0

rcall clr_disp
rcall power_up_wait

loop:
nop
rjmp loop

read_char:
lds data, UDR1
mov char, data
sts UDR1, char
inc counter
st X+, char
cpi counter, 80
brge main
reti

main:
ldi counter, 0
rcall print_one
ldi counter,0
rcall bufferspacer
ldi counter, 0
rcall print_two
rcall delay
rcall clr_disp
ldi counter, 0
rcall print_two
ldi counter, 0
rcall bufferspacer
ldi counter, 0
rcall print_three
rcall delay
rcall clr_disp
ldi counter, 0
rcall print_three
ldi counter, 0
rcall bufferspacer
ldi counter, 0
rcall print_four
rcall delay
rcall clr_disp
rjmp main
reti

print_one:
init1:
ldi XH, HIGH(MEMORY)
ldi XL, LOW(MEMORY)
print1:
ld data, X+
inc counter
rcall write_char
rcall short_wait
cpi counter, 20
brne print1
ret

print_two:
init2:
ldi XH, HIGH(MEMORY+20)
ldi XL, LOW(MEMORY+20)
print2:
ld data, X+
inc counter
rcall write_char
rcall short_wait
cpi counter, 20
brne print2
ret

print_three:
init3:
ldi XH, HIGH(MEMORY+40)
ldi XL, LOW(MEMORY+40)
print3:
ld data, X+
inc counter
rcall write_char
rcall short_wait
cpi counter, 20
brne print3
ret

print_four:
init4:
ldi XH, HIGH(MEMORY+60)
ldi XL, LOW(MEMORY+60)
print4:
ld data, X+
inc counter
rcall write_char
rcall short_wait
cpi counter, 20
brne print4
ret

bufferspacer:
ldi data, 33
rcall write_char
rcall short_wait
inc counter
cpi counter, 20
brne bufferspacer
ret

; Generated by delay loop calculator
; at http://www.bretmulvey.com/avrdelay.html
;
; Delay 9 217 175 cycles
; 5s at 1.843435 MHz
delay:
    ldi  r18, 47
    ldi  r19, 193
    ldi  r20, 180
 dec  r20
    brne delay
    dec  r19
    brne delay
    dec  r18
    brne delay
    nop

clr_disp:   
ldi Data, CLEAR           ; clr display
rcall write_cmd           ; send command
rcall long_wait           ; wait min. 1.53 ms
ret

; **
; ** write char/command
; **
write_char:        
ldi RS, 0b00100000        ; RS = high
rjmp write

write_cmd:     
clr RS                    ; RS = low

write:    
mov Temp, Data            ; copy Data
andi Data, 0b11110000     ; mask out high nibble
swap Data                 ; swap nibbles
or Data, RS               ; add register select
rcall write_nibble        ; send high nibble
mov Data, Temp            ; restore Data
andi Data, 0b00001111     ; mask out low nibble
or Data, RS               ; add register select

write_nibble:
rcall switch_output       ; Modify for display JHD202A, port E
nop                       ; wait 542nS
sbi PORTE, 5              ; enable high, JHD202A
nop
nop                       ; wait 542nS
cbi PORTE, 5              ; enable low, JHD202A
nop
nop                       ; wait 542nS
ret

; **
; ** busy_wait loop
; **
short_wait:    
clr zh                    ; approx 50 us
ldi zl, 30
rjmp wait_loop

long_wait:    
ldi zh, HIGH(1000)        ; approx 2 ms
ldi zh, LOW(1000)
rjmp wait_loop

dbnc_wait:    
ldi zh, HIGH(4600)        ; approx 10 ms
ldi zl, LOW(4600)
rjmp wait_loop

power_up_wait:
ldi zh, HIGH(9000)        ; approx 20 ms
ldi zl, LOW(9000)

wait_loop:    
sbiw z, 1                 ; 2 cycles
brne wait_loop            ; 2 cycles
ret

; **
; ** modify output signal to fit LCD JHD202A, connected to port E
; **
switch_output:
push Temp
clr Temp
sbrc Data, 0                ; D4 = 1?
ori Temp, 0b00000100            ; Set pin 2 
sbrc Data, 1                ; D5 = 1?
ori Temp, 0b00001000            ; Set pin 3 
sbrc Data, 2                ; D6 = 1?
ori Temp, 0b00000001            ; Set pin 0 
sbrc Data, 3                ; D7 = 1?
ori Temp, 0b00000010            ; Set pin 1 
sbrc Data, 4                ; E = 1?
ori Temp, 0b00100000            ; Set pin 5 
sbrc Data, 5                ; RS = 1?
ori Temp, 0b10000000            ; Set pin 7 (wrong in previous version)
out PORTE, Temp
pop Temp
ret



